// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BookingStatus string

const (
	BookingStatusPENDING   BookingStatus = "PENDING"
	BookingStatusCONFIRMED BookingStatus = "CONFIRMED"
	BookingStatusCANCELLED BookingStatus = "CANCELLED"
)

func (e *BookingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BookingStatus(s)
	case string:
		*e = BookingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BookingStatus: %T", src)
	}
	return nil
}

type NullBookingStatus struct {
	BookingStatus BookingStatus
	Valid         bool // Valid is true if BookingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBookingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BookingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BookingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBookingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BookingStatus), nil
}

type DifficultyLevel string

const (
	DifficultyLevelEASY   DifficultyLevel = "EASY"
	DifficultyLevelMEDIUM DifficultyLevel = "MEDIUM"
	DifficultyLevelHARD   DifficultyLevel = "HARD"
)

func (e *DifficultyLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DifficultyLevel(s)
	case string:
		*e = DifficultyLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for DifficultyLevel: %T", src)
	}
	return nil
}

type NullDifficultyLevel struct {
	DifficultyLevel DifficultyLevel
	Valid           bool // Valid is true if DifficultyLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDifficultyLevel) Scan(value interface{}) error {
	if value == nil {
		ns.DifficultyLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DifficultyLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDifficultyLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DifficultyLevel), nil
}

type MaterialType string

const (
	MaterialTypePDF   MaterialType = "PDF"
	MaterialTypeIMAGE MaterialType = "IMAGE"
	MaterialTypeVIDEO MaterialType = "VIDEO"
	MaterialTypeLINK  MaterialType = "LINK"
	MaterialTypeAUDIO MaterialType = "AUDIO"
)

func (e *MaterialType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MaterialType(s)
	case string:
		*e = MaterialType(s)
	default:
		return fmt.Errorf("unsupported scan type for MaterialType: %T", src)
	}
	return nil
}

type NullMaterialType struct {
	MaterialType MaterialType
	Valid        bool // Valid is true if MaterialType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMaterialType) Scan(value interface{}) error {
	if value == nil {
		ns.MaterialType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MaterialType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMaterialType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MaterialType), nil
}

type PaymentMethod string

const (
	PaymentMethodCARD         PaymentMethod = "CARD"
	PaymentMethodPAYPAL       PaymentMethod = "PAYPAL"
	PaymentMethodBANKTRANSFER PaymentMethod = "BANK_TRANSFER"
	PaymentMethodCASH         PaymentMethod = "CASH"
)

func (e *PaymentMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentMethod(s)
	case string:
		*e = PaymentMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentMethod: %T", src)
	}
	return nil
}

type NullPaymentMethod struct {
	PaymentMethod PaymentMethod
	Valid         bool // Valid is true if PaymentMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentMethod) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentMethod), nil
}

type PaymentStatus string

const (
	PaymentStatusPENDING   PaymentStatus = "PENDING"
	PaymentStatusCOMPLETED PaymentStatus = "COMPLETED"
	PaymentStatusFAILED    PaymentStatus = "FAILED"
	PaymentStatusREFUNDED  PaymentStatus = "REFUNDED"
)

func (e *PaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatus(s)
	case string:
		*e = PaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatus: %T", src)
	}
	return nil
}

type NullPaymentStatus struct {
	PaymentStatus PaymentStatus
	Valid         bool // Valid is true if PaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatus), nil
}

type Role string

const (
	RoleCLIENT Role = "CLIENT"
	RoleGUIDE  Role = "GUIDE"
	RoleADMIN  Role = "ADMIN"
)

func (e *Role) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Role(s)
	case string:
		*e = Role(s)
	default:
		return fmt.Errorf("unsupported scan type for Role: %T", src)
	}
	return nil
}

type NullRole struct {
	Role  Role
	Valid bool // Valid is true if Role is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRole) Scan(value interface{}) error {
	if value == nil {
		ns.Role, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Role.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Role), nil
}

type Article struct {
	ID          pgtype.UUID
	Slug        string
	Title       string
	Excerpt     string
	Content     string
	CoverUrl    string
	Alt         pgtype.Text
	Author      pgtype.Text
	Featured    bool
	PublishedAt pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

type Booking struct {
	ID           pgtype.UUID
	UserID       pgtype.UUID
	TourDateID   pgtype.UUID
	Status       BookingStatus
	Participants int32
	TotalPrice   float64
	CreatedAt    pgtype.Timestamp
	UpdatedAt    pgtype.Timestamp
}

type BookingRequest struct {
	ID        pgtype.UUID
	Name      string
	Phone     string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

type Category struct {
	ID   pgtype.UUID
	Name string
}

type Guide struct {
	ID              pgtype.UUID
	UserID          pgtype.UUID
	Experience      pgtype.Text
	Specializations []string
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
}

type PageMetadatum struct {
	Url       string
	Tags      string
	CreatedAt pgtype.Timestamp
	UpdatedAt pgtype.Timestamp
}

type Payment struct {
	ID            pgtype.UUID
	BookingID     pgtype.UUID
	Amount        float64
	PaymentMethod PaymentMethod
	Status        PaymentStatus
	TransactionID pgtype.Text
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
}

type Photo struct {
	ID          pgtype.UUID
	TourID      pgtype.UUID
	Url         string
	Description pgtype.Text
	CreatedAt   pgtype.Timestamp
}

type Review struct {
	ID        pgtype.UUID
	UserID    pgtype.UUID
	TourID    pgtype.UUID
	Rating    int32
	Comment   pgtype.Text
	UserName  string
	Link      string
	Image     string
	CreatedAt pgtype.Timestamp
}

type Tag struct {
	ID   pgtype.UUID
	Name string
}

type Tour struct {
	ID                pgtype.UUID
	Slug              string
	Title             string
	Description       string
	Difficulty        DifficultyLevel
	Price             pgtype.Float8
	Program           []byte
	Faq               []byte
	GuideID           pgtype.UUID
	CoverUrl          pgtype.Text
	DurationDays      pgtype.Int4
	EndLocation       pgtype.Text
	AvailableMonths   []string
	Languages         []string
	MinAge            pgtype.Int4
	StartLocation     pgtype.Text
	Location          pgtype.Text
	GroupSize         pgtype.Int4
	SpotsLeft         pgtype.Int4
	Subtitle          pgtype.Text
	PopUp1Title       string
	PopUp1Description string
	PopUp2Title       string
	PopUp2Description string
	PopUp1ImageUrl    string
	PopUp2ImageUrl    string
	CreatedAt         pgtype.Timestamp
	UpdatedAt         pgtype.Timestamp
}

type TourActivity struct {
	ID        pgtype.UUID
	TourID    pgtype.UUID
	Activity  string
	CreatedAt pgtype.Timestamp
}

type TourCategory struct {
	CategoryID pgtype.UUID
	TourID     pgtype.UUID
}

type TourDate struct {
	ID          pgtype.UUID
	TourID      pgtype.UUID
	DateFrom    pgtype.Timestamp
	DateTo      pgtype.Timestamp
	GroupSize   int32
	IsAvailable bool
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

type TourIncluded struct {
	ID        pgtype.UUID
	TourID    pgtype.UUID
	Included  string
	CreatedAt pgtype.Timestamp
}

type TourMaterial struct {
	ID        pgtype.UUID
	TourID    pgtype.UUID
	Title     string
	Url       string
	Type      MaterialType
	CreatedAt pgtype.Timestamp
}

type TourSummary struct {
	ID        pgtype.UUID
	TourID    pgtype.UUID
	Name      string
	Value     string
	CreatedAt pgtype.Timestamp
}

type TourTag struct {
	TagID  pgtype.UUID
	TourID pgtype.UUID
}

type User struct {
	ID            pgtype.UUID
	Email         string
	Password      string
	FirstName     string
	LastName      string
	Phone         pgtype.Text
	Bio           pgtype.Text
	ProfilePicUrl pgtype.Text
	Role          Role
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
}

type Video struct {
	ID          pgtype.UUID
	TourID      pgtype.UUID
	Url         string
	Description pgtype.Text
	CreatedAt   pgtype.Timestamp
}
