// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tour_query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTour = `-- name: CreateTour :one
INSERT INTO tours (
    title,
    description,
    difficulty,
    program,
    price,
    start_location,
    end_location,
    duration_days,
    min_age,
    cover_url,
    languages,
    available_months,
    guide_id
) VALUES (
    $1,
    $2,
    $3::difficulty_level,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13
) RETURNING
    id,
    slug,
    title,
    description,
    difficulty,
    price,
    program,
    guide_id,
    cover_url,
    duration_days,
    end_location,
    available_months,
    languages,
    min_age,
    start_location,
    location,
    created_at,
    updated_at
`

type CreateTourParams struct {
	Title           string
	Description     string
	Difficulty      DifficultyLevel
	Program         []byte
	Price           pgtype.Float8
	StartLocation   pgtype.Text
	EndLocation     pgtype.Text
	DurationDays    pgtype.Int4
	MinAge          pgtype.Int4
	CoverUrl        pgtype.Text
	Languages       []string
	AvailableMonths []string
	GuideID         pgtype.UUID
}

func (q *Queries) CreateTour(ctx context.Context, arg CreateTourParams) (Tour, error) {
	row := q.db.QueryRow(ctx, createTour,
		arg.Title,
		arg.Description,
		arg.Difficulty,
		arg.Program,
		arg.Price,
		arg.StartLocation,
		arg.EndLocation,
		arg.DurationDays,
		arg.MinAge,
		arg.CoverUrl,
		arg.Languages,
		arg.AvailableMonths,
		arg.GuideID,
	)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Difficulty,
		&i.Price,
		&i.Program,
		&i.GuideID,
		&i.CoverUrl,
		&i.DurationDays,
		&i.EndLocation,
		&i.AvailableMonths,
		&i.Languages,
		&i.MinAge,
		&i.StartLocation,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTourByID = `-- name: DeleteTourByID :execrows
DELETE FROM tours
WHERE id = $1
`

func (q *Queries) DeleteTourByID(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTourByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getTourByID = `-- name: GetTourByID :one
SELECT
    id,
    slug,
    title,
    description,
    difficulty,
    price,
    program,
    guide_id,
    cover_url,
    duration_days,
    end_location,
    available_months,
    languages,
    min_age,
    start_location,
    location,
    created_at,
    updated_at
FROM tours
WHERE id = $1
`

func (q *Queries) GetTourByID(ctx context.Context, id pgtype.UUID) (Tour, error) {
	row := q.db.QueryRow(ctx, getTourByID, id)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Difficulty,
		&i.Price,
		&i.Program,
		&i.GuideID,
		&i.CoverUrl,
		&i.DurationDays,
		&i.EndLocation,
		&i.AvailableMonths,
		&i.Languages,
		&i.MinAge,
		&i.StartLocation,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTourBySlug = `-- name: GetTourBySlug :one
SELECT
    id,
    slug,
    title,
    description,
    difficulty,
    price,
    program,
    guide_id,
    cover_url,
    duration_days,
    end_location,
    available_months,
    languages,
    min_age,
    start_location,
    location,
    created_at,
    updated_at
FROM tours
WHERE slug = $1
`

func (q *Queries) GetTourBySlug(ctx context.Context, slug string) (Tour, error) {
	row := q.db.QueryRow(ctx, getTourBySlug, slug)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Difficulty,
		&i.Price,
		&i.Program,
		&i.GuideID,
		&i.CoverUrl,
		&i.DurationDays,
		&i.EndLocation,
		&i.AvailableMonths,
		&i.Languages,
		&i.MinAge,
		&i.StartLocation,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTours = `-- name: GetTours :many
SELECT DISTINCT
    tours.id,
    tours.slug,
    tours.title,
    tours.description,
    tours.difficulty,
    tours.price,
    tours.program,
    tours.guide_id,
    tours.cover_url,
    tours.duration_days,
    tours.end_location,
    tours.available_months,
    tours.languages,
    tours.min_age,
    tours.start_location,
    tours.location,
    tours.created_at,
    tours.updated_at
FROM tours
LEFT JOIN tour_dates ON tours.id = tour_dates.tour_id AND tour_dates.is_available = TRUE
WHERE
    ($1::text IS NULL
        OR tours.start_location ILIKE '%' || $1::text || '%'
        OR tours.end_location ILIKE '%' || $1::text || '%')
    AND ($2::timestamp IS NULL OR tour_dates.date_to >= $2::timestamp)
    AND ($3::timestamp IS NULL OR tour_dates.date_from <= $3::timestamp)
    AND ($4::int IS NULL OR tour_dates.group_size >= $4::int)
    AND ($5::float IS NULL OR tours.price >= $5::float)
    AND ($6::float IS NULL OR tours.price <= $6::float)
    AND ($7::int[] IS NULL OR EXTRACT(MONTH FROM tour_dates.date_from)::int = ANY($7::int[]))
ORDER BY tours.created_at DESC
LIMIT $9 OFFSET $8
`

type GetToursParams struct {
	Location     pgtype.Text
	DateFrom     pgtype.Timestamp
	DateTo       pgtype.Timestamp
	GroupSize    pgtype.Int4
	PriceMin     pgtype.Float8
	PriceMax     pgtype.Float8
	SeasonMonths []int32
	OffsetCount  int32
	LimitCount   int32
}

func (q *Queries) GetTours(ctx context.Context, arg GetToursParams) ([]Tour, error) {
	rows, err := q.db.Query(ctx, getTours,
		arg.Location,
		arg.DateFrom,
		arg.DateTo,
		arg.GroupSize,
		arg.PriceMin,
		arg.PriceMax,
		arg.SeasonMonths,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tour{}
	for rows.Next() {
		var i Tour
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.Description,
			&i.Difficulty,
			&i.Price,
			&i.Program,
			&i.GuideID,
			&i.CoverUrl,
			&i.DurationDays,
			&i.EndLocation,
			&i.AvailableMonths,
			&i.Languages,
			&i.MinAge,
			&i.StartLocation,
			&i.Location,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTourByID = `-- name: UpdateTourByID :one
UPDATE tours
SET
    title = COALESCE($1, title),
    slug = COALESCE($2, slug),
    description = COALESCE($3, description),
    difficulty = COALESCE($4::difficulty_level, difficulty),
    program = COALESCE($5, program),
    price = COALESCE($6, price),
    start_location = COALESCE($7, start_location),
    end_location = COALESCE($8, end_location),
    duration_days = COALESCE($9, duration_days),
    min_age = COALESCE($10, min_age),
    cover_url = COALESCE($11, cover_url),
    languages = COALESCE($12, languages),
    available_months = COALESCE($13, available_months),
    guide_id = COALESCE($14, guide_id),
    updated_at = NOW()
WHERE id = $15
RETURNING
    id,
    slug,
    title,
    description,
    difficulty,
    price,
    program,
    guide_id,
    cover_url,
    duration_days,
    end_location,
    available_months,
    languages,
    min_age,
    start_location,
    location,
    created_at,
    updated_at
`

type UpdateTourByIDParams struct {
	Title           pgtype.Text
	Slug            pgtype.Text
	Description     pgtype.Text
	Difficulty      NullDifficultyLevel
	Program         []byte
	Price           pgtype.Float8
	StartLocation   pgtype.Text
	EndLocation     pgtype.Text
	DurationDays    pgtype.Int4
	MinAge          pgtype.Int4
	CoverUrl        pgtype.Text
	Languages       []string
	AvailableMonths []string
	GuideID         pgtype.UUID
	ID              pgtype.UUID
}

func (q *Queries) UpdateTourByID(ctx context.Context, arg UpdateTourByIDParams) (Tour, error) {
	row := q.db.QueryRow(ctx, updateTourByID,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Difficulty,
		arg.Program,
		arg.Price,
		arg.StartLocation,
		arg.EndLocation,
		arg.DurationDays,
		arg.MinAge,
		arg.CoverUrl,
		arg.Languages,
		arg.AvailableMonths,
		arg.GuideID,
		arg.ID,
	)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Difficulty,
		&i.Price,
		&i.Program,
		&i.GuideID,
		&i.CoverUrl,
		&i.DurationDays,
		&i.EndLocation,
		&i.AvailableMonths,
		&i.Languages,
		&i.MinAge,
		&i.StartLocation,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
