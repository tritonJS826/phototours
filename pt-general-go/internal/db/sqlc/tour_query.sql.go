// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tour_query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTour = `-- name: CreateTour :one
INSERT INTO tours (
    title,
    description,
    difficulty,
    program,
    faq,
    price,
    start_location,
    end_location,
    duration_days,
    min_age,
    cover_url,
    languages,
    available_months,
    guide_id,
    group_size,
    spots_left,
    subtitle,
    pop_up1_title,
    pop_up1_description,
    pop_up2_title,
    pop_up2_description,
    pop_up1_image_url,
    pop_up2_image_url
) VALUES (
    $1,
    $2,
    $3::difficulty_level,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21,
    $22,
    $23
) RETURNING
    id,
    slug,
    title,
    description,
    difficulty,
    price,
    program,
    faq,
    guide_id,
    cover_url,
    duration_days,
    end_location,
    available_months,
    languages,
    min_age,
    start_location,
    location,
    group_size,
    spots_left,
    subtitle,
    pop_up1_title,
    pop_up1_description,
    pop_up2_title,
    pop_up2_description,
    pop_up1_image_url,
    pop_up2_image_url,
    created_at,
    updated_at
`

type CreateTourParams struct {
	Title             string
	Description       string
	Difficulty        DifficultyLevel
	Program           []byte
	Faq               []byte
	Price             pgtype.Float8
	StartLocation     pgtype.Text
	EndLocation       pgtype.Text
	DurationDays      pgtype.Int4
	MinAge            pgtype.Int4
	CoverUrl          pgtype.Text
	Languages         []string
	AvailableMonths   []string
	GuideID           pgtype.UUID
	GroupSize         pgtype.Int4
	SpotsLeft         pgtype.Int4
	Subtitle          pgtype.Text
	PopUp1Title       string
	PopUp1Description string
	PopUp2Title       string
	PopUp2Description string
	PopUp1ImageUrl    string
	PopUp2ImageUrl    string
}

func (q *Queries) CreateTour(ctx context.Context, arg CreateTourParams) (Tour, error) {
	row := q.db.QueryRow(ctx, createTour,
		arg.Title,
		arg.Description,
		arg.Difficulty,
		arg.Program,
		arg.Faq,
		arg.Price,
		arg.StartLocation,
		arg.EndLocation,
		arg.DurationDays,
		arg.MinAge,
		arg.CoverUrl,
		arg.Languages,
		arg.AvailableMonths,
		arg.GuideID,
		arg.GroupSize,
		arg.SpotsLeft,
		arg.Subtitle,
		arg.PopUp1Title,
		arg.PopUp1Description,
		arg.PopUp2Title,
		arg.PopUp2Description,
		arg.PopUp1ImageUrl,
		arg.PopUp2ImageUrl,
	)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Difficulty,
		&i.Price,
		&i.Program,
		&i.Faq,
		&i.GuideID,
		&i.CoverUrl,
		&i.DurationDays,
		&i.EndLocation,
		&i.AvailableMonths,
		&i.Languages,
		&i.MinAge,
		&i.StartLocation,
		&i.Location,
		&i.GroupSize,
		&i.SpotsLeft,
		&i.Subtitle,
		&i.PopUp1Title,
		&i.PopUp1Description,
		&i.PopUp2Title,
		&i.PopUp2Description,
		&i.PopUp1ImageUrl,
		&i.PopUp2ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTourByID = `-- name: DeleteTourByID :execrows
DELETE FROM tours
WHERE id = $1
`

func (q *Queries) DeleteTourByID(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTourByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getTourByID = `-- name: GetTourByID :one
SELECT
    id,
    slug,
    title,
    description,
    difficulty,
    price,
    program,
    faq,
    guide_id,
    cover_url,
    duration_days,
    end_location,
    available_months,
    languages,
    min_age,
    start_location,
    location,
    group_size,
    spots_left,
    subtitle,
    pop_up1_title,
    pop_up1_description,
    pop_up2_title,
    pop_up2_description,
    pop_up1_image_url,
    pop_up2_image_url,
    created_at,
    updated_at
FROM tours
WHERE id = $1
`

func (q *Queries) GetTourByID(ctx context.Context, id pgtype.UUID) (Tour, error) {
	row := q.db.QueryRow(ctx, getTourByID, id)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Difficulty,
		&i.Price,
		&i.Program,
		&i.Faq,
		&i.GuideID,
		&i.CoverUrl,
		&i.DurationDays,
		&i.EndLocation,
		&i.AvailableMonths,
		&i.Languages,
		&i.MinAge,
		&i.StartLocation,
		&i.Location,
		&i.GroupSize,
		&i.SpotsLeft,
		&i.Subtitle,
		&i.PopUp1Title,
		&i.PopUp1Description,
		&i.PopUp2Title,
		&i.PopUp2Description,
		&i.PopUp1ImageUrl,
		&i.PopUp2ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTourBySlug = `-- name: GetTourBySlug :one
SELECT
    id,
    slug,
    title,
    description,
    difficulty,
    price,
    program,
    faq,
    guide_id,
    cover_url,
    duration_days,
    end_location,
    available_months,
    languages,
    min_age,
    start_location,
    location,
    group_size,
    spots_left,
    subtitle,
    pop_up1_title,
    pop_up1_description,
    pop_up2_title,
    pop_up2_description,
    pop_up1_image_url,
    pop_up2_image_url,
    created_at,
    updated_at
FROM tours
WHERE slug = $1
`

func (q *Queries) GetTourBySlug(ctx context.Context, slug string) (Tour, error) {
	row := q.db.QueryRow(ctx, getTourBySlug, slug)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Difficulty,
		&i.Price,
		&i.Program,
		&i.Faq,
		&i.GuideID,
		&i.CoverUrl,
		&i.DurationDays,
		&i.EndLocation,
		&i.AvailableMonths,
		&i.Languages,
		&i.MinAge,
		&i.StartLocation,
		&i.Location,
		&i.GroupSize,
		&i.SpotsLeft,
		&i.Subtitle,
		&i.PopUp1Title,
		&i.PopUp1Description,
		&i.PopUp2Title,
		&i.PopUp2Description,
		&i.PopUp1ImageUrl,
		&i.PopUp2ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTours = `-- name: GetTours :many
SELECT DISTINCT
    tours.id,
    tours.slug,
    tours.title,
    tours.description,
    tours.difficulty,
    tours.price,
    tours.program,
    tours.faq,
    tours.guide_id,
    tours.cover_url,
    tours.duration_days,
    tours.end_location,
    tours.available_months,
    tours.languages,
    tours.min_age,
    tours.start_location,
    tours.location,
    tours.group_size,
    tours.spots_left,
    tours.subtitle,
    tours.pop_up1_title,
    tours.pop_up1_description,
    tours.pop_up2_title,
    tours.pop_up2_description,
    tours.pop_up1_image_url,
    tours.pop_up2_image_url,
    tours.created_at,
    tours.updated_at
FROM tours
LEFT JOIN tour_dates ON tours.id = tour_dates.tour_id AND tour_dates.is_available = TRUE
WHERE
    ($1::text IS NULL
        OR tours.start_location ILIKE '%' || $1::text || '%'
        OR tours.end_location ILIKE '%' || $1::text || '%')
    AND ($2::timestamp IS NULL OR tour_dates.date_to >= $2::timestamp)
    AND ($3::timestamp IS NULL OR tour_dates.date_from <= $3::timestamp)
    AND ($4::int IS NULL OR tour_dates.group_size >= $4::int)
    AND ($5::float IS NULL OR tours.price >= $5::float)
    AND ($6::float IS NULL OR tours.price <= $6::float)
    AND ($7::int[] IS NULL OR EXTRACT(MONTH FROM tour_dates.date_from)::int = ANY($7::int[]))
ORDER BY tours.created_at DESC
LIMIT $9 OFFSET $8
`

type GetToursParams struct {
	Location     pgtype.Text
	DateFrom     pgtype.Timestamp
	DateTo       pgtype.Timestamp
	GroupSize    pgtype.Int4
	PriceMin     pgtype.Float8
	PriceMax     pgtype.Float8
	SeasonMonths []int32
	OffsetCount  int32
	LimitCount   int32
}

func (q *Queries) GetTours(ctx context.Context, arg GetToursParams) ([]Tour, error) {
	rows, err := q.db.Query(ctx, getTours,
		arg.Location,
		arg.DateFrom,
		arg.DateTo,
		arg.GroupSize,
		arg.PriceMin,
		arg.PriceMax,
		arg.SeasonMonths,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tour{}
	for rows.Next() {
		var i Tour
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.Description,
			&i.Difficulty,
			&i.Price,
			&i.Program,
			&i.Faq,
			&i.GuideID,
			&i.CoverUrl,
			&i.DurationDays,
			&i.EndLocation,
			&i.AvailableMonths,
			&i.Languages,
			&i.MinAge,
			&i.StartLocation,
			&i.Location,
			&i.GroupSize,
			&i.SpotsLeft,
			&i.Subtitle,
			&i.PopUp1Title,
			&i.PopUp1Description,
			&i.PopUp2Title,
			&i.PopUp2Description,
			&i.PopUp1ImageUrl,
			&i.PopUp2ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTourByID = `-- name: UpdateTourByID :one
UPDATE tours
SET
    title = COALESCE($1, title),
    slug = COALESCE($2, slug),
    description = COALESCE($3, description),
    difficulty = COALESCE($4::difficulty_level, difficulty),
    program = COALESCE($5, program),
    faq = COALESCE($6, faq),
    price = COALESCE($7, price),
    start_location = COALESCE($8, start_location),
    end_location = COALESCE($9, end_location),
    duration_days = COALESCE($10, duration_days),
    min_age = COALESCE($11, min_age),
    cover_url = COALESCE($12, cover_url),
    languages = COALESCE($13, languages),
    available_months = COALESCE($14, available_months),
    guide_id = COALESCE($15, guide_id),
    group_size = COALESCE($16, group_size),
    spots_left = COALESCE($17, spots_left),
    subtitle = COALESCE($18, subtitle),
    pop_up1_title = COALESCE($19, pop_up1_title),
    pop_up1_description = COALESCE($20, pop_up1_description),
    pop_up2_title = COALESCE($21, pop_up2_title),
    pop_up2_description = COALESCE($22, pop_up2_description),
    pop_up1_image_url = COALESCE($23, pop_up1_image_url),
    pop_up2_image_url = COALESCE($24, pop_up2_image_url),
    updated_at = NOW()
WHERE id = $25
RETURNING
    id,
    slug,
    title,
    description,
    difficulty,
    price,
    program,
    faq,
    guide_id,
    cover_url,
    duration_days,
    end_location,
    available_months,
    languages,
    min_age,
    start_location,
    location,
    group_size,
    spots_left,
    subtitle,
    pop_up1_title,
    pop_up1_description,
    pop_up2_title,
    pop_up2_description,
    pop_up1_image_url,
    pop_up2_image_url,
    created_at,
    updated_at
`

type UpdateTourByIDParams struct {
	Title             pgtype.Text
	Slug              pgtype.Text
	Description       pgtype.Text
	Difficulty        NullDifficultyLevel
	Program           []byte
	Faq               []byte
	Price             pgtype.Float8
	StartLocation     pgtype.Text
	EndLocation       pgtype.Text
	DurationDays      pgtype.Int4
	MinAge            pgtype.Int4
	CoverUrl          pgtype.Text
	Languages         []string
	AvailableMonths   []string
	GuideID           pgtype.UUID
	GroupSize         pgtype.Int4
	SpotsLeft         pgtype.Int4
	Subtitle          pgtype.Text
	PopUp1Title       pgtype.Text
	PopUp1Description pgtype.Text
	PopUp2Title       pgtype.Text
	PopUp2Description pgtype.Text
	PopUp1ImageUrl    pgtype.Text
	PopUp2ImageUrl    pgtype.Text
	ID                pgtype.UUID
}

func (q *Queries) UpdateTourByID(ctx context.Context, arg UpdateTourByIDParams) (Tour, error) {
	row := q.db.QueryRow(ctx, updateTourByID,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Difficulty,
		arg.Program,
		arg.Faq,
		arg.Price,
		arg.StartLocation,
		arg.EndLocation,
		arg.DurationDays,
		arg.MinAge,
		arg.CoverUrl,
		arg.Languages,
		arg.AvailableMonths,
		arg.GuideID,
		arg.GroupSize,
		arg.SpotsLeft,
		arg.Subtitle,
		arg.PopUp1Title,
		arg.PopUp1Description,
		arg.PopUp2Title,
		arg.PopUp2Description,
		arg.PopUp1ImageUrl,
		arg.PopUp2ImageUrl,
		arg.ID,
	)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Difficulty,
		&i.Price,
		&i.Program,
		&i.Faq,
		&i.GuideID,
		&i.CoverUrl,
		&i.DurationDays,
		&i.EndLocation,
		&i.AvailableMonths,
		&i.Languages,
		&i.MinAge,
		&i.StartLocation,
		&i.Location,
		&i.GroupSize,
		&i.SpotsLeft,
		&i.Subtitle,
		&i.PopUp1Title,
		&i.PopUp1Description,
		&i.PopUp2Title,
		&i.PopUp2Description,
		&i.PopUp1ImageUrl,
		&i.PopUp2ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
